# ADR-005: PostgreSQL Persistence with SQLAlchemy and Alembic

## Status

Proposed

## Context

ADR-001 through ADR-004 established in-memory correctness for the payments-core domain. Stage 1 proved that our business rules, idempotency semantics, and concurrency model work correctly with in-memory repositories and threading locks.

Stage 2 introduces **durable persistence** with PostgreSQL. This ADR addresses:

1. How to map domain entities to database tables without polluting the domain layer
2. How to implement repository ports with SQLAlchemy
3. How to manage transactions (Unit of Work pattern)
4. How to replace in-memory locks with database-level locking
5. How to use database transaction time as the authoritative time source
6. How to structure migrations with Alembic

The goal is to preserve all correctness guarantees from Stage 1 while adding durability and preparing for multi-instance deployments.

## Decision

### 1. Technology Stack

| Component | Choice | Rationale |
|-----------|--------|-----------|
| Database | PostgreSQL 16+ | ACID transactions, robust locking, JSON support |
| ORM | SQLAlchemy 2.0+ | Mature, well-documented, async support |
| Migrations | Alembic | Native SQLAlchemy integration, transactional DDL |
| Driver | psycopg (sync) | psycopg3 is the modern sync driver |

**Async consideration**: Stage 2 uses synchronous SQLAlchemy. Async (`asyncpg`) may be introduced in a future ADR if performance requirements demand it. Premature async adds complexity without clear benefit.

### 2. Layer Separation: ORM Models vs Domain Entities

**Principle**: Domain entities remain pure Python dataclasses. ORM models are infrastructure concerns.

```
┌─────────────────────────────────────────────────────────────────┐
│                        Domain Layer                              │
│  Payment (frozen dataclass)    Capture (frozen dataclass)        │
│  - Pure business logic         - Pure business logic             │
│  - No SQLAlchemy imports       - No SQLAlchemy imports           │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 │ Data Mapper
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Infrastructure Layer                          │
│  PaymentModel (SQLAlchemy)     CaptureModel (SQLAlchemy)         │
│  - Table mapping               - Table mapping                   │
│  - DB-specific concerns        - DB-specific concerns            │
└─────────────────────────────────────────────────────────────────┘
```

**Why separate models?**

| Aspect | Domain Entity | ORM Model |
|--------|---------------|-----------|
| Purpose | Business logic | Persistence mapping |
| Mutability | Immutable (frozen) | Mutable (ORM requirement) |
| Dependencies | None | SQLAlchemy |
| Testing | No DB needed | Requires DB or mocking |
| Serialization | Simple | Complex (lazy loading, sessions) |

References:
- [Cosmic Python - Repository Pattern](https://www.cosmicpython.com/book/chapter_02_repository.html)
- [DDD in Python - Repository Implementation](https://dddinpython.com/index.php/2022/11/09/implementing-the-repository-pattern-using-sqlalchemy/)

### 3. File Structure

PostgreSQL-specific code lives in `infrastructure/postgres/` to be explicit about what we're dealing with:

```
src/payments_core/
├── infrastructure/
│   ├── postgres/
│   │   ├── __init__.py
│   │   ├── models.py           # ORM models
│   │   ├── mappers.py          # Entity ↔ Model conversion
│   │   ├── unit_of_work.py     # Transaction management
│   │   ├── time_provider.py    # DbTimeProvider
│   │   └── database.py         # Engine/session factory
│   ├── payment_repository.py   # InMemoryPaymentRepository + PostgresPaymentRepository
│   ├── capture_repository.py   # InMemoryCaptureRepository + PostgresCaptureRepository
│   ├── time_provider.py        # SystemTimeProvider, FixedTimeProvider
│   └── lock_provider.py        # InMemoryLockProvider, NoOpLockProvider
```

Repository implementations live in the main infrastructure folder (`payment_repository.py`, `capture_repository.py`) alongside their in-memory counterparts. This keeps the port implementations together and makes swapping between them straightforward.

### 4. ORM Model Definitions

```python
# src/payments_core/infrastructure/postgres/models.py

from __future__ import annotations

from datetime import datetime
from uuid import UUID

from sqlalchemy import CheckConstraint, DateTime, Enum, ForeignKey, Index, Integer, MetaData, String, UniqueConstraint
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column

from payments_core.domain.entities import PaymentState


# Naming convention for predictable constraint names
convention = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s",
}

metadata = MetaData(naming_convention=convention)


class Base(DeclarativeBase):
    """Base class for all ORM models."""
    metadata = metadata


class PaymentModel(Base):
    """ORM model for payments table."""

    __tablename__ = "payments"

    id: Mapped[UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True)
    state: Mapped[str] = mapped_column(
        Enum(PaymentState, name="payment_state", create_constraint=True),
        nullable=False,
    )
    authorized_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    capture_expires_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    captured_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    captured_amount_cents: Mapped[int | None] = mapped_column(Integer)


class CaptureModel(Base):
    """ORM model for captures table."""

    __tablename__ = "captures"

    id: Mapped[UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True)
    payment_id: Mapped[UUID] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("payments.id", ondelete="RESTRICT"),
        nullable=False,
    )
    idempotency_key: Mapped[str] = mapped_column(String(64), nullable=False)
    amount_cents: Mapped[int] = mapped_column(Integer, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)

    __table_args__ = (
        # Idempotency constraint: one capture per (payment_id, idempotency_key)
        UniqueConstraint("payment_id", "idempotency_key", name="uq_captures_payment_idempotency"),
        # Index for idempotency lookups
        Index("ix_captures_payment_idempotency", "payment_id", "idempotency_key"),
        # Amount validation at DB level
        CheckConstraint("amount_cents > 0", name="ck_captures_amount_positive"),
    )
```

**Key design decisions**:

- **UUID primary keys**: Match domain value objects (`PaymentId`, `CaptureId`)
- **Timezone-aware timestamps**: `DateTime(timezone=True)` enforces UTC storage
- **Unique constraint on `(payment_id, idempotency_key)`**: Database-level idempotency enforcement (belt and suspenders with application logic)
- **Foreign key with `RESTRICT`**: Prevent orphaned captures
- **CHECK constraint**: `amount_cents > 0` enforced at DB level
- **No audit timestamps with server defaults**: Domain timestamps use DB transaction time explicitly (see Section 9)

#### Enum Strategy: Migrations as Source of Truth

The `PaymentState` enum appears in two places:

1. **Domain layer**: `PaymentState(Enum)` in `domain/entities/payment.py`
2. **ORM model**: `Enum(PaymentState, name="payment_state")` in models
3. **Migration**: `postgresql.ENUM("pending", "authorized", ...)` in Alembic

**Source of truth**: **Migrations are authoritative** for database schema.

| Layer | Role |
|-------|------|
| Domain `PaymentState` | Business logic, validation |
| ORM `Enum(PaymentState)` | Maps Python enum to DB column |
| Migration `postgresql.ENUM` | Creates the actual DB type |

**Why migrations are authoritative**:
- Migrations are versioned and reviewed
- Database state must match migration history
- ORM models describe "current" schema, migrations describe "how we got here"

**Avoiding drift**:
- When adding a new state, update in order: (1) domain enum, (2) migration, (3) deploy
- Use `alembic check` in CI to detect model/migration mismatches
- Never use `create_constraint=True` with autogenerate for enums—always write enum migrations manually

### 5. Data Mapper Functions

```python
# src/payments_core/infrastructure/postgres/mappers.py

from payments_core.domain.entities import Capture, Payment
from payments_core.domain.value_objects import CaptureId, IdempotencyKey, PaymentId
from payments_core.infrastructure.postgres.models import CaptureModel, PaymentModel


def payment_model_to_entity(model: PaymentModel) -> Payment:
    """Convert ORM model to domain entity."""
    return Payment(
        id=PaymentId(value=model.id),
        state=model.state,
        authorized_at=model.authorized_at,
        capture_expires_at=model.capture_expires_at,
        captured_at=model.captured_at,
        captured_amount_cents=model.captured_amount_cents,
    )


def capture_model_to_entity(model: CaptureModel) -> Capture:
    """Convert ORM model to domain entity."""
    return Capture(
        id=CaptureId(value=model.id),
        payment_id=PaymentId(value=model.payment_id),
        idempotency_key=IdempotencyKey(value=model.idempotency_key),
        amount_cents=model.amount_cents,
        created_at=model.created_at,
    )
```

### 6. Repository Implementations

Repositories are implemented in the main infrastructure folder, alongside their in-memory counterparts:

```python
# src/payments_core/infrastructure/payment_repository.py

from __future__ import annotations

import copy
from typing import TYPE_CHECKING

from sqlalchemy import select, update
from sqlalchemy.orm import Session

from payments_core.application.ports import PaymentRepository
from payments_core.infrastructure.postgres.mappers import payment_model_to_entity
from payments_core.infrastructure.postgres.models import PaymentModel

if TYPE_CHECKING:
    from payments_core.domain.entities import Payment
    from payments_core.domain.value_objects import PaymentId


class InMemoryPaymentRepository(PaymentRepository):
    """In-memory payment repository for testing and Stage 1."""
    # ... existing implementation unchanged ...


class PostgresPaymentRepository(PaymentRepository):
    """PostgreSQL payment repository using SQLAlchemy.

    Thread safety: This repository is NOT thread-safe. Each thread/request
    must use its own Session instance. The Unit of Work pattern manages
    session lifecycle.

    Locking: Row-level locking is handled via `get_for_update()` which uses
    SELECT ... FOR UPDATE.
    """

    def __init__(self, session: Session) -> None:
        self._session = session

    def get(self, payment_id: PaymentId) -> Payment | None:
        """Retrieve a payment by ID (no lock)."""
        stmt = select(PaymentModel).where(PaymentModel.id == payment_id.value)
        model = self._session.execute(stmt).scalar_one_or_none()
        if model is None:
            return None
        return payment_model_to_entity(model)

    def get_for_update(self, payment_id: PaymentId) -> tuple[Payment | None, PaymentModel | None]:
        """Retrieve a payment with FOR UPDATE lock.

        Returns both the domain entity AND the ORM model. The model is needed
        for subsequent updates (to avoid merge() pitfalls).

        The lock is held until transaction commit/rollback.
        """
        stmt = (
            select(PaymentModel)
            .where(PaymentModel.id == payment_id.value)
            .with_for_update()
        )
        model = self._session.execute(stmt).scalar_one_or_none()
        if model is None:
            return None, None
        return payment_model_to_entity(model), model

    def save(self, payment: Payment) -> None:
        """Insert a new payment.

        For updates, use update_from_entity() with the locked model instead.
        This avoids merge() pitfalls where a SELECT is issued before UPDATE.
        """
        model = PaymentModel(
            id=payment.id.value,
            state=payment.state,
            authorized_at=payment.authorized_at,
            capture_expires_at=payment.capture_expires_at,
            captured_at=payment.captured_at,
            captured_amount_cents=payment.captured_amount_cents,
        )
        self._session.add(model)

    def update_from_entity(self, model: PaymentModel, payment: Payment) -> None:
        """Update an existing payment model from a domain entity.

        This method mutates the already-loaded (and locked) ORM model,
        letting SQLAlchemy's dirty tracking handle the UPDATE.

        Args:
            model: The ORM model loaded via get_for_update()
            payment: The updated domain entity
        """
        model.state = payment.state
        model.authorized_at = payment.authorized_at
        model.capture_expires_at = payment.capture_expires_at
        model.captured_at = payment.captured_at
        model.captured_amount_cents = payment.captured_amount_cents
        # SQLAlchemy dirty tracking will issue UPDATE on flush/commit
```

```python
# src/payments_core/infrastructure/capture_repository.py

from __future__ import annotations

import copy
from typing import TYPE_CHECKING

from sqlalchemy import select
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session

from payments_core.application.ports import CaptureRepository
from payments_core.domain.exceptions import DuplicateCaptureError
from payments_core.infrastructure.postgres.mappers import capture_model_to_entity
from payments_core.infrastructure.postgres.models import CaptureModel

if TYPE_CHECKING:
    from payments_core.domain.entities import Capture
    from payments_core.domain.value_objects import IdempotencyKey, PaymentId


class InMemoryCaptureRepository(CaptureRepository):
    """In-memory capture repository for testing and Stage 1."""
    # ... existing implementation unchanged ...


class PostgresCaptureRepository(CaptureRepository):
    """PostgreSQL capture repository using SQLAlchemy."""

    def __init__(self, session: Session) -> None:
        self._session = session

    def get_by_idempotency_key(
        self,
        payment_id: PaymentId,
        idempotency_key: IdempotencyKey,
    ) -> Capture | None:
        """Retrieve a capture by payment ID and idempotency key."""
        stmt = select(CaptureModel).where(
            CaptureModel.payment_id == payment_id.value,
            CaptureModel.idempotency_key == idempotency_key.value,
        )
        model = self._session.execute(stmt).scalar_one_or_none()
        if model is None:
            return None
        return capture_model_to_entity(model)

    def save(self, capture: Capture) -> None:
        """Persist a capture.

        Raises:
            DuplicateCaptureError: If (payment_id, idempotency_key) already exists.
        """
        model = CaptureModel(
            id=capture.id.value,
            payment_id=capture.payment_id.value,
            idempotency_key=capture.idempotency_key.value,
            amount_cents=capture.amount_cents,
            created_at=capture.created_at,
        )
        self._session.add(model)
        try:
            self._session.flush()  # Force constraint check
        except IntegrityError as e:
            if "uq_captures_payment_idempotency" in str(e):
                raise DuplicateCaptureError(
                    f"Capture already exists for payment_id={capture.payment_id}, "
                    f"idempotency_key={capture.idempotency_key}"
                ) from e
            raise
```

**Why no merge()?**

`merge()` is convenient but dangerous:

| Problem | Risk |
|---------|------|
| Issues a SELECT before UPDATE | Extra round-trip, potential for stale reads |
| Can overwrite concurrent updates | Lost update anomaly if misused |
| Hides insert vs update intent | Makes debugging harder |

**Preferred pattern**: Load with `FOR UPDATE`, mutate the loaded model, let SQLAlchemy's dirty tracking handle the UPDATE. This makes write intent explicit and ensures we're updating the row we locked.

### 7. Unit of Work Pattern

The Unit of Work manages transaction boundaries and repository access. One business operation = one transaction.

```python
# src/payments_core/infrastructure/postgres/unit_of_work.py

from __future__ import annotations

from datetime import datetime
from typing import TYPE_CHECKING

from sqlalchemy import create_engine, text
from sqlalchemy.orm import Session, sessionmaker

from payments_core.infrastructure.capture_repository import PostgresCaptureRepository
from payments_core.infrastructure.payment_repository import PostgresPaymentRepository

if TYPE_CHECKING:
    from payments_core.application.ports import CaptureRepository, PaymentRepository


class PostgresUnitOfWork:
    """Unit of Work for PostgreSQL transactions.

    Usage:
        with uow:
            payment, model = uow.payments.get_for_update(payment_id)
            # ... business logic ...
            uow.payments.update_from_entity(model, updated_payment)
            uow.commit()

    The context manager ensures:
    - Session is created at entry
    - Session is closed at exit (commit or rollback)
    - Rollback on exception

    This class is NOT thread-safe. Create one instance per request/thread.
    """

    def __init__(self, session_factory: sessionmaker[Session]) -> None:
        self._session_factory = session_factory
        self._session: Session | None = None

    def __enter__(self) -> PostgresUnitOfWork:
        self._session = self._session_factory()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        if exc_type is not None:
            self.rollback()
        self.close()

    @property
    def session(self) -> Session:
        if self._session is None:
            raise RuntimeError("UnitOfWork not entered. Use 'with uow:' context.")
        return self._session

    @property
    def payments(self) -> PostgresPaymentRepository:
        return PostgresPaymentRepository(self.session)

    @property
    def captures(self) -> PostgresCaptureRepository:
        return PostgresCaptureRepository(self.session)

    def now(self) -> datetime:
        """Get database transaction time.

        Uses CURRENT_TIMESTAMP which returns the transaction start time,
        ensuring consistent time within a single transaction.
        """
        result = self.session.execute(text("SELECT CURRENT_TIMESTAMP"))
        return result.scalar_one()

    def commit(self) -> None:
        """Commit the current transaction."""
        self.session.commit()

    def rollback(self) -> None:
        """Rollback the current transaction."""
        self.session.rollback()

    def close(self) -> None:
        """Close the session."""
        if self._session is not None:
            self._session.close()
            self._session = None


def create_session_factory(database_url: str) -> sessionmaker[Session]:
    """Create a session factory for the given database URL."""
    engine = create_engine(
        database_url,
        pool_pre_ping=True,
        pool_size=5,
        max_overflow=10,
        pool_recycle=3600,
    )
    return sessionmaker(
        bind=engine,
        autocommit=False,
        autoflush=False,
        expire_on_commit=False,
    )
```

**Key configuration choices**:

| Setting | Value | Rationale |
|---------|-------|-----------|
| `autocommit` | `False` | Explicit transaction control |
| `autoflush` | `False` | Predictable flush timing |
| `expire_on_commit` | `False` | Avoid lazy-load errors after commit |
| `pool_pre_ping` | `True` | Handle stale connections gracefully |

References:
- [SQLAlchemy Session Basics](https://docs.sqlalchemy.org/en/20/orm/session_basics.html)
- [Cosmic Python - Unit of Work Pattern](https://www.cosmicpython.com/book/chapter_06_uow.html)

### 8. Updated Use Case with Database Persistence

The `CapturePaymentUseCase` with PostgreSQL maintains the same ordering guarantees as Stage 1:

**Critical**: Idempotency checks are performed **while holding the payment row lock**, exactly like Stage 1.

```python
# src/payments_core/application/use_cases/capture_payment.py (PostgreSQL version)

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING, Callable

from payments_core.domain.entities import Capture, PaymentState
from payments_core.domain.exceptions import (
    IdempotencyKeyReuseError,
    PaymentAlreadyCapturedError,
    PaymentExpiredError,
    PaymentNotFoundError,
)

if TYPE_CHECKING:
    from payments_core.domain.value_objects import IdempotencyKey, PaymentId
    from payments_core.infrastructure.postgres.unit_of_work import PostgresUnitOfWork


@dataclass(frozen=True, slots=True)
class CapturePaymentRequest:
    """Input DTO for capture payment use case."""
    payment_id: PaymentId
    idempotency_key: IdempotencyKey
    amount_cents: int


@dataclass(frozen=True, slots=True)
class CapturePaymentResponse:
    """Output DTO for capture payment use case."""
    capture: Capture
    is_replay: bool


class CapturePaymentUseCase:
    """Orchestrates the capture payment workflow with database persistence.

    Key differences from Stage 1:
    - Uses PostgresUnitOfWork for transaction management
    - Uses SELECT FOR UPDATE for row-level locking (replaces LockProvider)
    - Uses database transaction time (replaces TimeProvider)
    - Idempotency checks happen INSIDE the lock boundary (unchanged from Stage 1)
    """

    def __init__(self, uow_factory: Callable[[], PostgresUnitOfWork]) -> None:
        self._uow_factory = uow_factory

    def execute(self, request: CapturePaymentRequest) -> CapturePaymentResponse:
        """Execute the capture payment workflow."""
        with self._uow_factory() as uow:
            return self._execute_within_transaction(uow, request)

    def _execute_within_transaction(
        self,
        uow: PostgresUnitOfWork,
        request: CapturePaymentRequest,
    ) -> CapturePaymentResponse:
        """Execute capture logic within a database transaction.

        Operation order (preserves ADR-004 guarantees):
        1. Acquire row lock via SELECT FOR UPDATE
        2. Fetch transaction time INSIDE lock
        3. Check idempotency INSIDE lock
        4. Validate business rules
        5. Persist changes
        6. Commit
        """

        # Step 1: Fetch payment WITH LOCK
        # This establishes the serialization boundary (like LockProvider in Stage 1)
        payment, payment_model = uow.payments.get_for_update(request.payment_id)
        if payment is None:
            raise PaymentNotFoundError(f"Payment not found: {request.payment_id.value}")

        # Step 2: Fetch transaction time INSIDE lock
        # CURRENT_TIMESTAMP is consistent within the transaction
        now = uow.now()

        # Step 3: Check idempotency WHILE HOLDING LOCK
        # This is critical: prevents race where two requests both see "no capture"
        existing_capture = uow.captures.get_by_idempotency_key(
            request.payment_id, request.idempotency_key
        )
        if existing_capture is not None:
            return self._handle_idempotent_replay(existing_capture, request)

        # Step 4: Validate business rules
        if payment.state == PaymentState.CAPTURED:
            raise PaymentAlreadyCapturedError(
                f"Payment already captured: {request.payment_id.value}"
            )

        if not payment.can_capture(now):
            raise PaymentExpiredError(
                f"Capture window expired for payment: {request.payment_id.value}"
            )

        # Step 5: Create capture and update payment
        capture = Capture.create(
            payment_id=request.payment_id,
            idempotency_key=request.idempotency_key,
            amount_cents=request.amount_cents,
            created_at=now,
        )
        captured_payment = payment.capture(now, request.amount_cents)

        # Step 6: Persist changes
        # Capture inserted BEFORE payment update (ADR-004 Section 9):
        # If crash occurs after capture insert but before payment update,
        # idempotency check on retry will find the capture and replay.
        uow.captures.save(capture)
        uow.payments.update_from_entity(payment_model, captured_payment)

        # Step 7: Commit transaction (releases lock)
        uow.commit()

        return CapturePaymentResponse(capture=capture, is_replay=False)

    def _handle_idempotent_replay(
        self,
        existing_capture: Capture,
        request: CapturePaymentRequest,
    ) -> CapturePaymentResponse:
        """Handle replay of an existing capture."""
        if existing_capture.amount_cents != request.amount_cents:
            raise IdempotencyKeyReuseError(
                f"Idempotency key '{request.idempotency_key.value}' already used "
                f"with amount_cents={existing_capture.amount_cents}, "
                f"but request has amount_cents={request.amount_cents}"
            )
        return CapturePaymentResponse(capture=existing_capture, is_replay=True)
```

### 9. Time Provider Strategy: Database Transaction Time

Stage 2 uses **database transaction time** as the authoritative time source. This eliminates the split-brain time model where application code and database defaults could use different clocks.

```python
# src/payments_core/infrastructure/postgres/time_provider.py

from __future__ import annotations

from datetime import datetime

from sqlalchemy import text
from sqlalchemy.orm import Session

from payments_core.application.ports import TimeProvider


class DbTimeProvider(TimeProvider):
    """Time provider using PostgreSQL CURRENT_TIMESTAMP.

    CURRENT_TIMESTAMP returns the transaction start time, which is:
    - Consistent within a single transaction (multiple calls return same value)
    - Authoritative across all application instances
    - Not affected by application server clock skew

    Usage:
        This provider requires an active database session. It's typically
        accessed via the Unit of Work's now() method rather than directly.
    """

    def __init__(self, session: Session) -> None:
        self._session = session

    def now(self) -> datetime:
        """Return the current transaction timestamp (UTC)."""
        result = self._session.execute(text("SELECT CURRENT_TIMESTAMP"))
        return result.scalar_one()
```

**Why database time?**

| Problem with Application Time | Solution with DB Time |
|-------------------------------|----------------------|
| Clock skew across servers | Single source of truth |
| Different time for domain vs audit | Consistent timestamps |
| Tests pass locally, fail in DB | Same time source everywhere |

**PostgreSQL time functions**:

| Function | Behavior |
|----------|----------|
| `CURRENT_TIMESTAMP` | Transaction start time (stable within transaction) |
| `NOW()` | Alias for CURRENT_TIMESTAMP |
| `CLOCK_TIMESTAMP()` | Actual current time (changes within transaction) |
| `STATEMENT_TIMESTAMP()` | Statement start time |

We use `CURRENT_TIMESTAMP` because it's consistent within a transaction, ensuring that `capture.created_at` and expiry checks use the same time value.

### 10. Locking Strategy: SELECT FOR UPDATE

We replace `LockProvider` with database row-level locking via `SELECT ... FOR UPDATE`.

**Why row locks instead of in-memory locks?**

| Stage 1 (In-Memory) | Stage 2 (PostgreSQL) |
|---------------------|----------------------|
| `threading.Lock` per payment | `SELECT ... FOR UPDATE` |
| Single process only | Works across instances |
| Lost on restart | Tied to transaction |

**Lock acquisition order is critical**:

```python
# CORRECT: Lock first, then check idempotency
payment, model = uow.payments.get_for_update(payment_id)  # Lock acquired
existing = uow.captures.get_by_idempotency_key(...)       # Check inside lock

# WRONG: Check first, then lock (race condition!)
existing = uow.captures.get_by_idempotency_key(...)       # No lock yet
payment, model = uow.payments.get_for_update(payment_id)  # Too late
```

The wrong order allows:
1. Tx A checks captures → none found
2. Tx B checks captures → none found
3. Tx A locks payment, inserts capture
4. Tx B locks payment, attempts insert → unique constraint violation

While the constraint catches this, it converts a valid idempotent replay into an exception, violating ADR-004's ordering rule.

**Isolation level**: This design assumes PostgreSQL's default `READ COMMITTED` isolation; higher isolation levels (e.g., `SERIALIZABLE`) are unnecessary because row-level locking on the aggregate root (Payment) already serializes concurrent operations.

References:
- [PostgreSQL Explicit Locking](https://www.postgresql.org/docs/current/explicit-locking.html)
- [SQLAlchemy with_for_update()](https://dev.to/ivankwongtszfung/safe-update-operation-in-postgresql-using-sqlalchemy-3ela)

### 11. Alembic Migrations Setup

#### Directory Structure

```
payments-core/
├── alembic/
│   ├── versions/           # Migration scripts
│   ├── env.py              # Migration environment
│   └── script.py.mako      # Migration template
├── alembic.ini             # Alembic configuration
└── src/
    └── payments_core/
        └── infrastructure/
            └── postgres/
                └── models.py   # ORM models (source of truth)
```

#### Migration Best Practices

1. **Always review autogenerated migrations**: Alembic autogenerate is not perfect. Column renames appear as drop+add.

2. **Use `alembic check` in CI**: Fail builds if models are out of sync with migrations.

3. **Test rollbacks**: Every `upgrade()` should have a corresponding `downgrade()`.

4. **Transactional DDL**: PostgreSQL supports transactional DDL—migrations are atomic.

5. **Data migrations**: For data migrations, define static table structures in the migration file to avoid model drift issues.

References:
- [Alembic Tutorial](https://alembic.sqlalchemy.org/en/latest/tutorial.html)
- [Best Practices for Alembic](https://dev.to/welel/best-practices-for-alembic-and-sqlalchemy-3b34)

#### Initial Migration

```python
# alembic/versions/001_initial_schema.py

"""Initial schema for payments and captures.

Revision ID: 001
Create Date: 2024-XX-XX
"""

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

revision = "001"
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # Create payment_state enum
    payment_state = postgresql.ENUM(
        "pending", "authorized", "captured", "failed",
        name="payment_state",
        create_type=True,
    )
    payment_state.create(op.get_bind(), checkfirst=True)

    # Create payments table
    op.create_table(
        "payments",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True),
        sa.Column("state", payment_state, nullable=False),
        sa.Column("authorized_at", sa.DateTime(timezone=True)),
        sa.Column("capture_expires_at", sa.DateTime(timezone=True)),
        sa.Column("captured_at", sa.DateTime(timezone=True)),
        sa.Column("captured_amount_cents", sa.Integer()),
    )

    # Create captures table
    op.create_table(
        "captures",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True),
        sa.Column("payment_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("idempotency_key", sa.String(64), nullable=False),
        sa.Column("amount_cents", sa.Integer(), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
    )

    # Add constraints
    op.create_foreign_key(
        "fk_captures_payment_id_payments",
        "captures", "payments",
        ["payment_id"], ["id"],
        ondelete="RESTRICT",
    )
    op.create_unique_constraint(
        "uq_captures_payment_idempotency",
        "captures",
        ["payment_id", "idempotency_key"],
    )
    op.create_index(
        "ix_captures_payment_idempotency",
        "captures",
        ["payment_id", "idempotency_key"],
    )
    op.create_check_constraint(
        "ck_captures_amount_positive",
        "captures",
        "amount_cents > 0",
    )


def downgrade() -> None:
    op.drop_constraint("ck_captures_amount_positive", "captures")
    op.drop_index("ix_captures_payment_idempotency", "captures")
    op.drop_constraint("uq_captures_payment_idempotency", "captures")
    op.drop_constraint("fk_captures_payment_id_payments", "captures")
    op.drop_table("captures")
    op.drop_table("payments")
    op.execute("DROP TYPE IF EXISTS payment_state")
```

### 12. Database Constraints as Safety Net

The database enforces constraints that complement application logic:

| Constraint | Purpose | Application Check |
|------------|---------|-------------------|
| `UNIQUE(payment_id, idempotency_key)` | Prevent duplicate captures | Idempotency check in use case |
| `NOT NULL` on required fields | Data integrity | Domain validation |
| `FOREIGN KEY` payments→captures | Referential integrity | Domain logic |
| `CHECK(amount_cents > 0)` | Amount validation | `Capture.create()` |

**Belt and suspenders**: Application logic is the first line of defense; database constraints catch bugs that slip through.

### 13. Testing Strategy

#### Integration Tests with Real Database

```python
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from payments_core.infrastructure.postgres.models import Base


@pytest.fixture(scope="session")
def engine():
    """Create test database engine."""
    engine = create_engine("postgresql://test:test@localhost:5432/payments_test")
    Base.metadata.create_all(engine)
    yield engine
    Base.metadata.drop_all(engine)


@pytest.fixture
def session(engine):
    """Create a new session for each test with rollback."""
    connection = engine.connect()
    transaction = connection.begin()
    session = sessionmaker(bind=connection)()

    yield session

    session.close()
    transaction.rollback()
    connection.close()
```

#### Unit Tests with In-Memory Repositories

Existing in-memory repository tests remain valid. The `PostgresPaymentRepository` and `PostgresCaptureRepository` implement the same ports.

### 14. Connection Management

```python
# src/payments_core/infrastructure/postgres/database.py

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session


def create_engine_from_url(database_url: str):
    """Create database engine with connection pooling."""
    return create_engine(
        database_url,
        pool_pre_ping=True,
        pool_size=5,
        max_overflow=10,
        pool_recycle=3600,
    )


def create_session_factory(database_url: str) -> sessionmaker[Session]:
    """Create session factory for dependency injection."""
    engine = create_engine_from_url(database_url)
    return sessionmaker(
        bind=engine,
        autocommit=False,
        autoflush=False,
        expire_on_commit=False,
    )
```

## Consequences

### Positive

- **Durability**: Data survives process restarts
- **ACID guarantees**: True atomicity with rollback on failure
- **Multi-instance ready**: Row locks work across application instances
- **Clean separation**: Domain entities remain pure; ORM is infrastructure
- **Constraint enforcement**: Database provides additional safety layer
- **Testable**: In-memory repositories still work for unit tests
- **Consistent time**: Database transaction time eliminates clock skew issues

### Negative

- **Complexity**: More moving parts (ORM, migrations, connection management)
- **Performance overhead**: Network round-trips, connection pooling
- **Schema coupling**: Database schema must stay in sync with models
- **Learning curve**: SQLAlchemy 2.0, Alembic, PostgreSQL specifics

### Migration Path

1. Add PostgreSQL to Docker Compose
2. Implement ORM models in `infrastructure/postgres/models.py`
3. Implement mappers in `infrastructure/postgres/mappers.py`
4. Add PostgreSQL repository implementations to existing repository files
5. Implement Unit of Work in `infrastructure/postgres/unit_of_work.py`
6. Set up Alembic and create initial migration
7. Update use case to use PostgresUnitOfWork
8. Add integration tests

### LockProvider Status

`LockProvider` (ADR-003) is **not deprecated**. It serves different purposes depending on the persistence layer:

| Persistence | Locking Mechanism | LockProvider Role |
|-------------|-------------------|-------------------|
| In-memory (Stage 1) | `InMemoryLockProvider` | **Required** for concurrency |
| PostgreSQL (Stage 2) | `SELECT ... FOR UPDATE` | **Not used** (DB handles it) |

**Coexistence model**:

```python
# Stage 1: In-memory use case (uses LockProvider)
class CapturePaymentUseCase:
    def __init__(self, lock_provider, time_provider, payment_repo, capture_repo): ...

# Stage 2: PostgreSQL use case (uses UnitOfWork with row locks)
class CapturePaymentUseCase:
    def __init__(self, uow_factory): ...
```

The in-memory implementation remains valid for:
- Unit tests that don't need a database
- Local development without PostgreSQL
- Testing business logic in isolation

`NoOpLockProvider` continues to be used for single-threaded unit tests where concurrency isn't being verified.

### Related ADRs

- [ADR-001](ADR-001.md): Core Domain Model and In-Memory Correctness
- [ADR-002](ADR-002.md): Time Provider Interface and Implementation
- [ADR-003](ADR-003.md): Lock Provider Interface and In-Memory Implementation
- [ADR-004](ADR-004.md): Repository Interfaces and CapturePayment Use Case

### Future Work

- **Async SQLAlchemy**: If performance requires async I/O
- **Read replicas**: For read-heavy workloads
- **Connection pooling**: PgBouncer for high-concurrency deployments
- **Audit logging**: Capture rejected attempts, state transitions
