# ADR-002: Time Provider Interface and Implementation

## Status

Proposed

## Context

Time is a critical factor in payment processing. The capture window (`capture_expires_at`) requires reliable time comparisons. We need a time abstraction that:

- Enables deterministic testing of time-based scenarios
- Isolates the domain from infrastructure concerns
- Supports future migration to database time as the source of truth
- Prevents timezone-related bugs

## Decision

### 1. Port in Application Layer

The `TimeProvider` interface (port) lives in the **application layer**. Implementations live in the **infrastructure layer**.

```
src/payments_core/
├── application/
│   └── ports/
│       └── time_provider.py    # Abstract interface
└── infrastructure/
    └── time_provider.py        # SystemTimeProvider, FixedTimeProvider
```

This follows Clean Architecture: the application layer defines what it needs, infrastructure provides it.

### 2. Interface Definition

We use **ABC** (Abstract Base Class) for explicit interface enforcement and runtime error detection.

```python
from abc import ABC, abstractmethod
from datetime import UTC, datetime


class TimeProvider(ABC):
    """Port for time operations.

    Contract:
    - now() MUST return a datetime with tzinfo=datetime.UTC
    - now() MUST NOT return naive datetimes under any circumstance
    - Not just "timezone-aware"—specifically UTC (no -06:00 offsets)

    Naive datetime = bug. This is non-negotiable.
    """

    @abstractmethod
    def now(self) -> datetime:
        """Return the current UTC datetime (tzinfo=datetime.UTC)."""
```

**Note**: We use `datetime.UTC` (available in Python 3.11+) as the canonical UTC constant throughout the codebase.

### 3. Application Time for Stage 1

For Stage 1, we use **application server time** via `datetime.now(UTC)`.

```python
from datetime import UTC, datetime


class SystemTimeProvider(TimeProvider):
    """Production time provider using system clock."""

    def now(self) -> datetime:
        return datetime.now(UTC)
```

**Limitation**: Multiple application servers may have clock skew. This is acceptable for Stage 1 in-memory correctness.

**Future work**: ADR for database time (`SELECT NOW()`) will be introduced with PostgreSQL to establish a single source of truth. That ADR MUST explicitly document whether it uses PostgreSQL transaction time (`CURRENT_TIMESTAMP`), statement time, or clock time, as this choice affects correctness under retries and long-running transactions.

### 4. UTC Only Policy

**All internal timestamps are UTC.** The domain layer exclusively works with UTC-aware datetimes.

Timezone conversion happens **only at API boundaries**:

```
[Client Request]              [Domain]                    [Client Response]
     │                           │                              │
     ▼                           ▼                              ▼
 "2024-01-01T12:00:00Z"  →  datetime(UTC)  →  "2024-01-01T12:00:00Z"
 (or local time)              (always)         (ISO 8601 UTC)
```

The entrypoints layer is responsible for:
- Parsing incoming timestamps and converting to UTC
- Formatting outgoing timestamps as ISO 8601 with `Z` suffix

The domain **never** handles timezone conversion or naive datetimes.

### 5. Test Implementation

`FixedTimeProvider` returns a fixed timestamp that can be explicitly changed via `set_time()`.

```python
from datetime import UTC, datetime


class FixedTimeProvider(TimeProvider):
    """Test time provider with controllable fixed timestamp.

    Note: This implementation is NOT thread-safe. For Stage 1,
    it is intended for single-threaded unit tests only.
    """

    def __init__(self, fixed_time: datetime) -> None:
        self._validate_utc(fixed_time)
        self._fixed_time = fixed_time

    def now(self) -> datetime:
        return self._fixed_time

    def set_time(self, new_time: datetime) -> None:
        """Explicitly change the fixed time for testing scenarios."""
        self._validate_utc(new_time)
        self._fixed_time = new_time

    def _validate_utc(self, dt: datetime) -> None:
        if dt.tzinfo is not UTC:
            raise ValueError(
                f"datetime must have tzinfo=UTC, got tzinfo={dt.tzinfo}"
            )
```

**Concurrency note**: `FixedTimeProvider.set_time()` mutates internal state. In concurrent tests, one thread calling `set_time()` while another is mid-use-case causes unpredictable behavior. For Stage 1, this is acceptable—unit tests are single-threaded. If concurrent integration tests are added later, either:
- Use separate `FixedTimeProvider` instances per thread, or
- Add internal locking to `FixedTimeProvider`

### 6. UTC Validation in Infrastructure

`FixedTimeProvider` validates that input datetimes have `tzinfo=UTC` specifically—not just any timezone-aware value. This is **contract enforcement**, not domain logic.

- The `TimeProvider` interface promises `tzinfo=datetime.UTC`
- The test implementation ensures test authors don't accidentally pass `-06:00` or other offsets
- Validation happens at test setup time, catching bugs early

The domain trusts that `TimeProvider.now()` always returns `tzinfo=UTC` datetimes and does not re-validate.

### 7. Expiry Comparison Rule

Per ADR-001, capture is allowed only if `now < capture_expires_at`. The comparison uses strict less-than:

| Condition | Result |
|-----------|--------|
| `now < capture_expires_at` | Capture allowed |
| `now >= capture_expires_at` | `PaymentExpiredError` |

This means a capture request arriving at exactly the expiry time is **rejected**.

### 8. Usage in Use Cases

As defined in ADR-001, the use case fetches `now` **once** and passes it to domain methods:

```python
class CapturePaymentUseCase:
    def __init__(
        self,
        time_provider: TimeProvider,
        payment_repo: PaymentRepository,
        # ...
    ) -> None:
        self._time_provider = time_provider
        self._payment_repo = payment_repo

    def execute(self, request: CapturePaymentRequest) -> CapturePaymentResponse:
        now = self._time_provider.now()  # Single fetch

        payment = self._payment_repo.get(request.payment_id)

        if not payment.can_capture(now):  # Pass to domain
            raise PaymentExpiredError(...)

        # ... create capture with created_at=now
```

This ensures time consistency within a single operation.

**Concurrency note**: In concurrent implementations, `now` MUST be fetched **after** acquiring any per-payment lock to ensure time comparisons are consistent within the critical section. This binding between time and locking semantics is where many systems fail under load.

### 9. Testing Time-Based Scenarios

Use `FixedTimeProvider` with explicit `set_time()` calls:

```python
from datetime import UTC, datetime

import pytest


def test_capture_before_expiry(time_provider: FixedTimeProvider):
    # Payment expires at 12:00
    payment = create_authorized_payment(
        capture_expires_at=datetime(2024, 1, 1, 12, 0, 0, tzinfo=UTC)
    )

    # Set time to 11:00 (before expiry)
    time_provider.set_time(datetime(2024, 1, 1, 11, 0, 0, tzinfo=UTC))

    result = use_case.execute(capture_request)
    assert result.status == CaptureStatus.SUCCEEDED


def test_capture_at_exact_expiry(time_provider: FixedTimeProvider):
    # Payment expires at 12:00
    payment = create_authorized_payment(
        capture_expires_at=datetime(2024, 1, 1, 12, 0, 0, tzinfo=UTC)
    )

    # Set time to exactly 12:00 (at expiry boundary)
    time_provider.set_time(datetime(2024, 1, 1, 12, 0, 0, tzinfo=UTC))

    # now >= expires_at → rejected
    with pytest.raises(PaymentExpiredError):
        use_case.execute(capture_request)


def test_capture_after_expiry(time_provider: FixedTimeProvider):
    payment = create_authorized_payment(
        capture_expires_at=datetime(2024, 1, 1, 12, 0, 0, tzinfo=UTC)
    )

    # Set time to 13:00 (after expiry)
    time_provider.set_time(datetime(2024, 1, 1, 13, 0, 0, tzinfo=UTC))

    with pytest.raises(PaymentExpiredError):
        use_case.execute(capture_request)
```

## Consequences

### Positive

- **Testable**: Time-based scenarios are deterministic and explicit
- **Clean Architecture**: Port in application, implementation in infrastructure
- **Safe**: UTC validation catches test bugs at setup time
- **Simple**: Single `FixedTimeProvider` covers all Stage 1 test scenarios
- **Explicit**: `set_time()` makes time changes visible in tests

### Negative

- **Clock skew risk**: Application time may differ across servers (acceptable for Stage 1)
- **Manual test setup**: Each test must explicitly set the time (trade-off for explicitness)

### Related ADRs

- [ADR-001](ADR-001.md): Core Domain Model and In-Memory Correctness

### Future Work

- ADR for database time provider with PostgreSQL (must specify transaction vs statement vs clock time semantics)
- Consider `AdvancingTimeProvider` if integration tests need automatic time progression
