# ADR-004: Repository Interfaces and CapturePayment Use Case

## Status

Proposed

## Context

ADR-001 established the domain model and repository port signatures. ADR-002 and ADR-003 defined time and locking providers. This ADR completes the Stage 1 architecture by:

1. Defining full repository contracts (not just method signatures)
2. Specifying in-memory implementation patterns
3. Formalizing the `CapturePaymentUseCase` orchestration that ties all components together

The goal is to have a complete, testable in-memory implementation before introducing database persistence.

## Decision

### 1. Port and Implementation Location

Repository ports live in the **application layer**. In-memory implementations live in the **infrastructure layer** (flat structure, no `persistence/` subfolder for Stage 1).

```
src/payments_core/
├── application/
│   └── ports/
│       ├── payment_repository.py
│       ├── capture_repository.py
│       ├── time_provider.py
│       └── lock_provider.py
└── infrastructure/
    ├── in_memory_payment_repository.py
    ├── in_memory_capture_repository.py
    ├── time_provider.py
    └── locking.py
```

This maintains Clean Architecture (ports in application, adapters in infrastructure) while avoiding unnecessary directory depth for a small codebase.

### 2. PaymentRepository Interface

```python
from __future__ import annotations

from abc import ABC, abstractmethod

from payments_core.domain.entities import Payment
from payments_core.domain.value_objects import PaymentId


class PaymentRepository(ABC):
    """Port for payment persistence.

    Contract:
    - get() returns None if payment does not exist (no exception)
    - save() performs upsert: creates if new, updates if exists
    - Implementations are NOT thread-safe; callers must ensure serialization
    - PaymentId is immutable after entity creation

    Thread safety note:
    Repositories assume the caller has acquired appropriate locks via
    LockProvider before invoking methods. This matches database behavior
    where transaction isolation is external to the repository.
    """

    @abstractmethod
    def get(self, payment_id: PaymentId) -> Payment | None:
        """Retrieve a payment by ID.

        Args:
            payment_id: The payment identifier.

        Returns:
            The Payment entity if found, None otherwise.
            Returned entity is a copy; mutations do not affect stored state.
        """

    @abstractmethod
    def save(self, payment: Payment) -> None:
        """Persist a payment (upsert semantics).

        Args:
            payment: The payment entity to save.

        Creates the payment if it doesn't exist, updates if it does.
        The payment.id must not change between creation and updates.
        """
```

### 3. CaptureRepository Interface

```python
from __future__ import annotations

from abc import ABC, abstractmethod

from payments_core.domain.entities import Capture
from payments_core.domain.value_objects import IdempotencyKey, PaymentId


class CaptureRepository(ABC):
    """Port for capture persistence.

    Contract:
    - Only successful captures are stored (existence implies success)
    - get_by_idempotency_key() is scoped to a specific payment
    - Implementations are NOT thread-safe; callers must ensure serialization

    Design note:
    We do not store rejected capture attempts. Audit trail for rejections
    is deferred to a future ADR. This simplifies the model: if a Capture
    record exists for (payment_id, idempotency_key), it succeeded.
    """

    @abstractmethod
    def get_by_idempotency_key(
        self,
        payment_id: PaymentId,
        idempotency_key: IdempotencyKey,
    ) -> Capture | None:
        """Retrieve a capture by payment ID and idempotency key.

        Args:
            payment_id: The payment identifier.
            idempotency_key: The client-provided idempotency key.

        Returns:
            The Capture entity if found, None otherwise.
            Returned entity is a copy; mutations do not affect stored state.
        """

    @abstractmethod
    def save(self, capture: Capture) -> None:
        """Persist a successful capture.

        Args:
            capture: The capture entity to save.

        Raises:
            DuplicateCaptureError: If (payment_id, idempotency_key) already exists.
                This is an invariant violation—should never happen if the use case
                checks idempotency first inside the lock. Distinct from
                IdempotencyKeyReuseError, which is client misuse (HTTP 409).
        """
```

**Removed from ADR-001**: The `exists_successful(payment_id)` method is not needed. Payment state (`PaymentState.CAPTURED`) is the authoritative source for whether a payment has been captured.

**New domain exceptions** (add to ADR-001 Section 8):
- `InvalidAmountError`: Raised when `amount_cents <= 0`
- `DuplicateCaptureError`: Invariant violation if save encounters duplicate (should never happen if use case checks idempotency inside lock). Distinct from `IdempotencyKeyReuseError` (client misuse, HTTP 409).

### 4. Simplified Capture Entity

With only successful captures stored, the `CaptureStatus` enum is removed:

```python
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime

from payments_core.domain.value_objects import CaptureId, IdempotencyKey, PaymentId


@dataclass(frozen=True, slots=True)
class Capture:
    """A successful capture record.

    Captures are immutable. Existence of a Capture record implies
    the capture succeeded—there is no status field.
    """

    id: CaptureId
    payment_id: PaymentId
    idempotency_key: IdempotencyKey
    amount_cents: int
    created_at: datetime

    @classmethod
    def create(
        cls,
        payment_id: PaymentId,
        idempotency_key: IdempotencyKey,
        amount_cents: int,
        created_at: datetime,
    ) -> Capture:
        """Factory method to create a new Capture with generated ID.

        Args:
            payment_id: The payment being captured.
            idempotency_key: Client-provided idempotency key.
            amount_cents: Capture amount (must be > 0).
            created_at: Timestamp of capture creation.

        Returns:
            A new Capture instance.

        Raises:
            InvalidAmountError: If amount_cents <= 0.
        """
        if amount_cents <= 0:
            raise InvalidAmountError(
                f"amount_cents must be greater than 0, got {amount_cents}"
            )
        return cls(
            id=CaptureId.generate(),
            payment_id=payment_id,
            idempotency_key=idempotency_key,
            amount_cents=amount_cents,
            created_at=created_at,
        )
```

**Validation location**: The `amount_cents > 0` invariant (ADR-001 Section 6) is enforced in `Capture.create()`. This ensures invalid captures cannot be constructed, regardless of call site. Add `InvalidAmountError` to domain exceptions.

### 5. In-Memory Implementation Pattern

Both repositories use the same pattern: **simple dict with copy-on-read**.

```python
from __future__ import annotations

import copy

from payments_core.application.ports.payment_repository import PaymentRepository
from payments_core.domain.entities import Payment
from payments_core.domain.value_objects import PaymentId


class InMemoryPaymentRepository(PaymentRepository):
    """In-memory payment repository for testing and Stage 1.

    Implementation notes:
    - Uses dict with PaymentId as key (requires frozen dataclass)
    - Returns deep copies from get() to mimic database detachment
    - Stores deep copies in save() to prevent external mutation
    - NOT thread-safe; relies on external LockProvider for serialization

    Copy-on-read rationale:
    Returning copies catches bugs where code mutates an entity without
    calling save(). This mimics ORM behavior where fetched entities are
    detached from the session until explicitly merged/committed.

    Deepcopy assumptions:
    - All entities and value objects must be deepcopy-safe (frozen dataclasses are)
    - datetime objects with tzinfo=UTC survive deepcopy correctly
    - No external references (file handles, connections) in entities
    """

    def __init__(self) -> None:
        self._payments: dict[PaymentId, Payment] = {}

    def get(self, payment_id: PaymentId) -> Payment | None:
        payment = self._payments.get(payment_id)
        if payment is None:
            return None
        return copy.deepcopy(payment)

    def save(self, payment: Payment) -> None:
        self._payments[payment.id] = copy.deepcopy(payment)
```

```python
from __future__ import annotations

import copy

from payments_core.application.ports.capture_repository import CaptureRepository
from payments_core.domain.entities import Capture
from payments_core.domain.value_objects import IdempotencyKey, PaymentId


class InMemoryCaptureRepository(CaptureRepository):
    """In-memory capture repository for testing and Stage 1.

    Implementation notes:
    - Keyed by (PaymentId, IdempotencyKey) tuple for O(1) lookup
    - Returns deep copies from get_by_idempotency_key()
    - NOT thread-safe; relies on external LockProvider for serialization
    """

    def __init__(self) -> None:
        self._captures: dict[tuple[PaymentId, IdempotencyKey], Capture] = {}

    def get_by_idempotency_key(
        self,
        payment_id: PaymentId,
        idempotency_key: IdempotencyKey,
    ) -> Capture | None:
        capture = self._captures.get((payment_id, idempotency_key))
        if capture is None:
            return None
        return copy.deepcopy(capture)

    def save(self, capture: Capture) -> None:
        key = (capture.payment_id, capture.idempotency_key)
        if key in self._captures:
            raise DuplicateCaptureError(
                f"Capture already exists for payment_id={capture.payment_id}, "
                f"idempotency_key={capture.idempotency_key}"
            )
        self._captures[key] = copy.deepcopy(capture)
```

### 6. Thread Safety Model

Repositories are **not thread-safe by design**. Thread safety is the caller's responsibility via `LockProvider`.

```
┌─────────────────────────────────────────────────────────────┐
│                    CapturePaymentUseCase                    │
├─────────────────────────────────────────────────────────────┤
│  with lock_provider.acquire(payment_id):                    │
│      # All repository calls happen inside lock              │
│      capture = capture_repo.get_by_idempotency_key(...)     │
│      payment = payment_repo.get(...)                        │
│      ...                                                    │
│      capture_repo.save(capture)                             │
│      payment_repo.save(payment)                             │
└─────────────────────────────────────────────────────────────┘
```

**Why not lock inside repositories?**

| Approach | Pros | Cons |
|----------|------|------|
| External lock (chosen) | Matches DB transactions, single lock covers multiple operations | Caller must remember to lock |
| Internal lock per repo | Each repo is self-contained | Multiple locks = deadlock risk, can't span operations atomically |

This model translates directly to database implementations where `SELECT FOR UPDATE` or transaction isolation provides the serialization.

### 7. Atomicity Without Transactions

For Stage 1, atomicity is achieved through the combination of:

1. **LockProvider**: Serializes all operations on a payment
2. **In-memory state**: No partial writes (Python dict operations are atomic at the interpreter level)

There is no rollback mechanism. If an exception occurs after `capture_repo.save()` but before `payment_repo.save()`, the system may be in an inconsistent state.

**Mitigation for Stage 1**: The use case is structured to minimize this window:

```python
# Prepare all changes
capture = Capture.create(...)
payment.capture(now, amount_cents)

# Persist sequentially; inconsistency is a known Stage-1 limitation (see §9)
capture_repo.save(capture)
payment_repo.save(payment)
```

**Future work**: Database transactions will provide true atomicity with rollback.

### 8. CapturePaymentUseCase Implementation

The use case orchestrates all components from ADR-001, ADR-002, and ADR-003:

```python
from __future__ import annotations

from dataclasses import dataclass

from payments_core.application.ports.capture_repository import CaptureRepository
from payments_core.application.ports.lock_provider import LockProvider
from payments_core.application.ports.payment_repository import PaymentRepository
from payments_core.application.ports.time_provider import TimeProvider
from payments_core.domain.entities import Capture
from payments_core.domain.exceptions import (
    IdempotencyKeyReuseError,
    PaymentAlreadyCapturedError,
    PaymentExpiredError,
    PaymentNotFoundError,
)
from payments_core.domain.value_objects import IdempotencyKey, PaymentId, PaymentState


@dataclass(frozen=True, slots=True)
class CapturePaymentRequest:
    """Input DTO for capture payment use case."""

    payment_id: PaymentId
    idempotency_key: IdempotencyKey
    amount_cents: int


@dataclass(frozen=True, slots=True)
class CapturePaymentResponse:
    """Output DTO for capture payment use case."""

    capture: Capture
    is_replay: bool  # True if this was an idempotent replay


class CapturePaymentUseCase:
    """Orchestrates the capture payment workflow.

    Responsibilities:
    - Acquire per-payment lock (ADR-003)
    - Fetch current time inside lock (ADR-002)
    - Check idempotency FIRST (ADR-001 Section 7)
    - Validate business rules (ADR-001 Section 6)
    - Persist capture and update payment state

    This use case is the single entry point for capture operations.
    All concurrency, time, and persistence concerns are handled here.
    """

    def __init__(
        self,
        lock_provider: LockProvider,
        time_provider: TimeProvider,
        payment_repository: PaymentRepository,
        capture_repository: CaptureRepository,
    ) -> None:
        self._lock_provider = lock_provider
        self._time_provider = time_provider
        self._payment_repo = payment_repository
        self._capture_repo = capture_repository

    def execute(self, request: CapturePaymentRequest) -> CapturePaymentResponse:
        """Execute the capture payment workflow.

        Args:
            request: The capture request with payment_id, idempotency_key, amount.

        Returns:
            CapturePaymentResponse with the capture and replay indicator.

        Raises:
            PaymentNotFoundError: Payment does not exist.
            PaymentAlreadyCapturedError: Payment already captured (different key).
            PaymentExpiredError: Capture window has expired.
            IdempotencyKeyReuseError: Same key used with different amount.
        """
        # Step 1: Acquire lock (ADR-003)
        with self._lock_provider.acquire(str(request.payment_id.value)):
            return self._execute_within_lock(request)

    def _execute_within_lock(
        self, request: CapturePaymentRequest
    ) -> CapturePaymentResponse:
        """Execute capture logic within the lock's critical section."""

        # Step 2: Fetch time INSIDE lock (ADR-002)
        now = self._time_provider.now()

        # Step 3: Check idempotency FIRST (ADR-001 Section 7)
        existing_capture = self._capture_repo.get_by_idempotency_key(
            request.payment_id, request.idempotency_key
        )
        if existing_capture is not None:
            return self._handle_idempotent_replay(existing_capture, request)

        # Step 4: Fetch payment
        payment = self._payment_repo.get(request.payment_id)
        if payment is None:
            raise PaymentNotFoundError(
                f"Payment not found: {request.payment_id.value}"
            )

        # Step 5: Validate business rules (ADR-001 Section 6)
        if payment.state == PaymentState.CAPTURED:
            raise PaymentAlreadyCapturedError(
                f"Payment already captured: {request.payment_id.value}"
            )

        if not payment.can_capture(now):
            raise PaymentExpiredError(
                f"Capture window expired for payment: {request.payment_id.value}"
            )

        # Step 6: Create capture and update payment
        capture = Capture.create(
            payment_id=request.payment_id,
            idempotency_key=request.idempotency_key,
            amount_cents=request.amount_cents,
            created_at=now,
        )
        payment.capture(now, request.amount_cents)

        # Step 7: Persist (order: capture first, then payment)
        self._capture_repo.save(capture)
        self._payment_repo.save(payment)

        return CapturePaymentResponse(capture=capture, is_replay=False)

    def _handle_idempotent_replay(
        self,
        existing_capture: Capture,
        request: CapturePaymentRequest,
    ) -> CapturePaymentResponse:
        """Handle replay of an existing capture.

        Per ADR-001 Section 7:
        - Exact match (same amount): return existing capture
        - Payload mismatch (different amount): raise IdempotencyKeyReuseError
        """
        if existing_capture.amount_cents != request.amount_cents:
            raise IdempotencyKeyReuseError(
                f"Idempotency key '{request.idempotency_key.value}' already used "
                f"with amount_cents={existing_capture.amount_cents}, "
                f"but request has amount_cents={request.amount_cents}"
            )

        return CapturePaymentResponse(capture=existing_capture, is_replay=True)
```

### 9. Operation Order Rationale

The order of operations in `_execute_within_lock` is deliberate:

| Step | Operation | Rationale |
|------|-----------|-----------|
| 1 | Acquire lock | Serialize all operations for this payment |
| 2 | Fetch time | Time must be consistent within critical section (ADR-002) |
| 3 | Check idempotency | Return early for replays, even if payment is now captured (ADR-001) |
| 4 | Fetch payment | After idempotency—replay doesn't need current payment state |
| 5 | Validate rules | Business rules depend on current state and time |
| 6 | Create entities | Prepare all changes before persistence |
| 7 | Persist | Capture first (creates audit trail), then payment state |

**Why persist capture before payment?**

We choose capture-first ordering, but acknowledge a **known limitation** in Stage 1's no-transaction model.

If the process crashes between the two saves:
- Capture saved, payment not updated → Capture exists, payment still `AUTHORIZED`
- Next request with **same key** → Idempotent replay returns existing capture ✓
- Next request with **different key** → **Succeeds** (payment still `AUTHORIZED`, passes `can_capture()`) ✗

This creates an inconsistent state: multiple capture records for the same payment with *different* idempotency keys. (Repository uniqueness is per `(payment_id, idempotency_key)`, so `DuplicateCaptureError` doesn't catch this—each key is unique.) The payment only transitions to `CAPTURED` once, on whichever request completes both saves.

**Why this is acceptable for Stage 1:**
- Crashes between two dict operations are extremely rare in practice
- The alternative (payment-first) is worse: payment `CAPTURED` with no capture record breaks idempotency entirely
- Capture-first at least preserves idempotency for the original request

**Why this won't happen with database transactions:**
A database transaction wraps both saves atomically—either both succeed or both roll back. See Future Work.

| Crash Scenario | Capture-First (chosen) | Payment-First |
|----------------|------------------------|---------------|
| Same key retry | ✓ Idempotent replay | ✗ No capture to replay |
| Different key retry | ✗ May create duplicate | ✓ Rejected (already captured) |
| Data consistency | Capture orphan possible | Captured without record |

We accept the capture-first trade-off because idempotency is the primary contract with clients.

### 10. Testing Strategy

#### Unit Tests (with NoOpLockProvider)

Test business logic without concurrency:

```python
def test_capture_success(
    use_case: CapturePaymentUseCase,
    payment_repo: InMemoryPaymentRepository,
    authorized_payment: Payment,
):
    payment_repo.save(authorized_payment)

    request = CapturePaymentRequest(
        payment_id=authorized_payment.id,
        idempotency_key=IdempotencyKey("test-key"),
        amount_cents=1000,
    )

    response = use_case.execute(request)

    assert response.is_replay is False
    assert response.capture.amount_cents == 1000
```

#### Concurrency Tests (with InMemoryLockProvider)

Test race conditions per ADR-003 Section 10:

```python
def test_concurrent_capture_same_key():
    """Two threads, same (payment_id, idempotency_key) → one capture, both get same result."""
    # Implementation uses threading + barriers

def test_concurrent_capture_different_keys():
    """Two threads, same payment, different keys → one succeeds, one gets AlreadyCaptured."""
    # Implementation uses threading + barriers
```

#### Repository Tests

Test copy-on-read behavior:

```python
def test_get_returns_copy(payment_repo: InMemoryPaymentRepository):
    """Mutating returned entity does not affect stored state."""
    original = create_payment()
    payment_repo.save(original)

    fetched = payment_repo.get(original.id)
    fetched.state = PaymentState.FAILED  # Mutate the copy

    stored = payment_repo.get(original.id)
    assert stored.state == original.state  # Original unchanged
```

## Consequences

### Positive

- **Complete Stage 1**: All components defined and integrated
- **Testable**: In-memory implementations enable fast, deterministic tests
- **Simple**: No CaptureStatus enum, no Unit of Work complexity
- **Safe**: Copy-on-read catches mutation bugs early
- **Clear contracts**: Repository behavior fully specified

### Negative

- **No rollback**: Exception between saves leaves inconsistent state
- **No rejected audit**: Rejected captures not persisted (deferred)
- **Copy overhead**: Deep copy on every get/save (acceptable for Stage 1)
- **Memory growth**: In-memory repositories grow unbounded

### Amendments to Previous ADRs

This ADR supersedes the following from ADR-001:
- **Section 4 (CaptureStatus)**: Removed. Only successful captures are stored.
- **Section 9 (Repository Ports)**: `exists_successful()` removed from CaptureRepository.

### Related ADRs

- [ADR-001](ADR-001.md): Core Domain Model and In-Memory Correctness
- [ADR-002](ADR-002.md): Time Provider Interface and Implementation
- [ADR-003](ADR-003.md): Lock Provider Interface and In-Memory Implementation

### Future Work

- **Database transactions / Unit of Work**: Eliminates the crash-window inconsistency documented in Section 9. Both capture and payment saves will be atomic.
- Database persistence with PostgreSQL (true transactions, rollback)
- Rejected capture audit trail (separate table or event log)
- Repository query methods (list, filter) as needed
