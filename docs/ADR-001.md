# ADR-001: Core Domain Model and In-Memory Correctness

## Status

Proposed

## Context

We need to establish the foundational domain model for the payments-core service. This model must support:

- A strict payment state machine with explicit transitions
- Idempotent capture requests
- Time-based capture windows
- Correctness under concurrent access

This ADR focuses on **in-memory correctness** without database dependencies. The goal is to validate business rules and invariants before introducing persistence complexity.

## Decision

### 1. Payment Entity (Rich Domain Model)

We adopt a **rich domain model** where the `Payment` entity encapsulates its own behavior and enforces state transitions internally.

```python
class Payment:
    id: PaymentId
    state: PaymentState
    authorized_at: datetime | None
    capture_expires_at: datetime | None
    captured_at: datetime | None
    captured_amount_cents: int | None
```

The entity exposes methods like `authorize()` and `can_capture(now: datetime)` that enforce business rules. Invalid transitions raise domain exceptions.

### 2. Payment State Machine

States are represented as an enum:

```python
class PaymentState(Enum):
    PENDING = "pending"
    AUTHORIZED = "authorized"
    CAPTURED = "captured"
    FAILED = "failed"
```

Valid transitions:

| From | To | Trigger |
|------|-----|---------|
| `pending` | `authorized` | Authorization succeeds |
| `authorized` | `captured` | Capture succeeds within window |
| `authorized` | `failed` | Explicit failure (not expiry) |

Terminal state: `captured` (no further transitions allowed).

**Expiry policy**: Window expiration does **not** auto-transition the payment. The payment remains in `AUTHORIZED` state, but capture attempts after `capture_expires_at` are rejected with `PaymentExpiredError`. This is a deliberate design choice—expired authorizations may be handled by a separate cleanup process or left as-is.

### 3. Capture as Separate Entity

`Capture` is a **separate entity** linked to `Payment` by `payment_id`. This enables:

- Tracking capture attempts independently
- Idempotency key storage per attempt
- Future extensibility (capture history, partial captures)

```python
class Capture:
    id: CaptureId
    payment_id: PaymentId
    idempotency_key: IdempotencyKey
    status: CaptureStatus
    amount_cents: int
    created_at: datetime
```

### 4. Capture Status

For Stage 1, we define a minimal status enum:

```python
class CaptureStatus(Enum):
    SUCCEEDED = "succeeded"
    REJECTED = "rejected"
```

| Status | When Written |
|--------|--------------|
| `SUCCEEDED` | Capture completes successfully, payment transitions to `CAPTURED` |
| `REJECTED` | Business rule rejection (expired window, payment already captured, invalid state) |

**Note**: We do not store `PENDING` or `FAILED` (internal error) captures in Stage 1. A capture record is created only when we have a definitive outcome.

### 5. Value Objects

| Value Object | Format | Validation |
|--------------|--------|------------|
| `PaymentId` | UUID v4 | Must be valid UUID |
| `CaptureId` | UUID v4 | Must be valid UUID |
| `IdempotencyKey` | String | Non-empty, max 64 chars |

Value objects are **immutable** and created via factory methods that validate input.

```python
@dataclass(frozen=True)
class PaymentId:
    value: UUID

    @classmethod
    def generate(cls) -> "PaymentId": ...

    @classmethod
    def from_string(cls, value: str) -> "PaymentId": ...
```

### 6. Domain Invariants

The domain layer enforces these invariants:

1. **State transition validity**: Only allowed transitions are permitted
2. **Terminal state immutability**: `captured` payments cannot transition
3. **Capture window enforcement**: Capture only succeeds if `now < capture_expires_at`
4. **Single successful capture**: If `payment.state == CAPTURED`, all future capture attempts are rejected—even with new idempotency keys. The payment state is the gate.
5. **Idempotency**: Same `(payment_id, idempotency_key)` returns same result
6. **Amount validity**: `amount_cents` must be greater than 0. Stage 1 assumes **full capture only**—we do not track `authorized_amount_cents` or enforce `capture <= authorized`. Partial capture support is deferred to a future ADR.

### 7. Idempotency Semantics

**Check order**: Under concurrency, the correct rule is: **check idempotency key first**, then enforce capture eligibility. This ensures a replay of the same key returns the original capture result even after the payment transitions to `CAPTURED`—without special-casing.

```python
# 1. Check idempotency FIRST
existing = capture_repo.get_by_idempotency_key(payment_id, idempotency_key)
if existing:
    if existing.amount_cents != request.amount_cents:
        raise IdempotencyKeyReuseError(
            "Idempotency key reused with different amount"
        )
    return existing  # Idempotent replay (even if payment is now CAPTURED)

# 2. THEN check capture eligibility
if payment.state == PaymentState.CAPTURED:
    raise PaymentAlreadyCapturedError(...)
if not payment.can_capture(now):
    raise PaymentExpiredError(...)
```

**Exact match**: If a capture with `(payment_id, idempotency_key)` exists and the request `amount_cents` matches the stored capture, return the existing capture result.

**Payload mismatch**: If a capture with `(payment_id, idempotency_key)` exists but `amount_cents` differs from the request, raise `IdempotencyKeyReuseError` (HTTP 409 Conflict). Do not mutate anything.

This ordering prevents undefined behavior and ensures idempotent replays work correctly under all conditions.

### 8. Domain Exceptions

```python
class DomainException(Exception): ...
class InvalidStateTransitionError(DomainException): ...
class PaymentExpiredError(DomainException): ...
class PaymentAlreadyCapturedError(DomainException): ...
class PaymentNotFoundError(DomainException): ...
class InvalidPaymentIdError(DomainException): ...
class InvalidIdempotencyKeyError(DomainException): ...
class IdempotencyKeyReuseError(DomainException): ...
```

### 9. Repository Ports

Abstract interfaces for persistence (implemented in-memory for Stage 1):

```python
class PaymentRepository(ABC):
    def get(self, payment_id: PaymentId) -> Payment | None: ...
    def save(self, payment: Payment) -> None: ...

class CaptureRepository(ABC):
    def get_by_idempotency_key(
        self, payment_id: PaymentId, key: IdempotencyKey
    ) -> Capture | None: ...
    def exists_successful(self, payment_id: PaymentId) -> bool: ...
    def save(self, capture: Capture) -> None: ...
```

The `exists_successful` method enables efficient single-capture enforcement without scanning all captures.

### 10. Time Provider and Usage

Time is injected via `TimeProvider`. See [ADR-002](ADR-002.md) for the complete specification of the time provider interface, UTC policy, and implementation details.

Key points from ADR-002:
- The domain **never** calls `datetime.now()` directly
- All datetimes MUST have `tzinfo=datetime.UTC`
- Naive datetimes are bugs

**Time source location**: The `CapturePayment` use case fetches `now = time_provider.now()` **once** at the start of the operation and passes it to domain methods:

```python
class CapturePaymentUseCase:
    def execute(self, request: CapturePaymentRequest) -> CapturePaymentResponse:
        now = self.time_provider.now()  # Single source of truth for this operation

        # ... fetch payment ...

        if not payment.can_capture(now):
            raise PaymentExpiredError(...)

        # ... create capture with created_at=now ...
```

This ensures time consistency within a single operation.

### 11. Locking Strategy (In-Memory)

For in-memory correctness, we use per-payment locks via `LockProvider` (already scaffolded). The `CapturePayment` use case acquires a lock before checking state and creating captures.

**Lock key requirement**: The lock key **must be canonical and stable** across processes, serialization boundaries, and persistence layers. This ensures the same payment always maps to the same lock, regardless of how the `PaymentId` value object is represented.

For Stage 1, use the UUID string form:

```python
with lock_provider.acquire(str(payment_id.value)):
    # 1. Check idempotency (return early if replay)
    # 2. Validate state and time window
    # 3. Create capture
    # 4. Update payment state
```

This mental model holds when moving to database locks or distributed locking—the key derivation must remain deterministic and stable.

## Consequences

### Positive

- **Testable**: All business logic can be tested without infrastructure
- **Clear boundaries**: Domain exceptions make invalid states unrepresentable
- **Portable**: Switching from in-memory to PostgreSQL only requires new repository implementations
- **Deterministic**: Injected time provider enables reliable time-based tests
- **Safe idempotency**: Payload mismatch detection prevents silent corruption

### Negative

- **In-memory limitations**: No durability, no cross-process consistency
- **Lock granularity**: In-memory locks don't work across multiple instances
- **No history**: Current state only; capture history deferred to future ADR
- **No auto-expiry**: Expired authorizations remain in `AUTHORIZED` state

### Related ADRs

- [ADR-002](ADR-002.md): Time Provider Interface and Implementation

### Future Work

- ADR-003: PostgreSQL persistence with transactional guarantees
- ADR-004: Database-level locking (SELECT FOR UPDATE)
- ADR-005: Capture history and audit trail
- ADR-006: Authorization expiry cleanup policy
